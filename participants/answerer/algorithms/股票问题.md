# 股票问题汇总

[买卖股票的最佳时机I](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)

只能进行一次交易，所以我们只需要贪心地选取当前位置作为卖，对应的最大值，显然，买的是之前区间最小值。

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int mn = prices[0];
        int ans = 0;
        for(int i: prices){
            ans = max(ans, i - mn);
            mn = min(mn, i);
        }
        return ans;
    }
};
```

[买卖股票的最佳时机II](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/)

需要有两个状态：`f[i][0]`定义为考虑前i个位置，处于买入状态的最大值；`f[i][1]`定义为考虑前i个位置，处于卖出状态的最大值。

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int n = prices.size();
        vector <vector<int>> f(n, vector <int> (2));
        f[0][0] = -prices[0];
        int ans = 0;
        for(int i = 1; i < n; i++){
            f[i][1] = max(f[i - 1][0] + prices[i], f[i - 1][1]);
            f[i][0] =  max(f[i - 1][0], f[i - 1][1] - prices[i]);
            ans = max(ans, f[i][1]);
        }
        return ans;
    }
};
```

[买卖股票的最佳时机III](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/submissions/)

需要多一维记录卖出次数，其他的与之前一致。

```cpp
int f[3 * 101000][2][3];
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int n = prices.size();
        for(int i = 0; i < 2; i++){
            for(int j = 0; j < 2; j++){
                f[0][i][j] = 0;
            }
        }
        f[0][0][0] = -prices[0], f[0][0][1] = -prices[0];
        for(int i = 1; i < n; i++){
            //买入没进行交易
            f[i][0][0] = max(f[i - 1][0][0], -prices[i]);
            //第一次交易
            f[i][1][0] = max(f[i - 1][1][0], f[i - 1][0][0] + prices[i]);
            //第二次买入
            f[i][0][1] = max(f[i - 1][0][1], f[i - 1][1][0] - prices[i]);
            //第二次卖出
            f[i][1][1] = max(f[i - 1][1][1], f[i - 1][0][1] + prices[i]);
        }
        return f[n - 1][1][1];
    }
};

```
