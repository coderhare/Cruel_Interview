### 什么是系统调用？
根据进程访问资源的特点，可以把进程在系统上的运行分为两个级别：
- 用户态(user mode) : 用户态运行的进程或可以直接读取用户程序的数据。
- 系统态(kernel mode):可以简单的理解系统态运行的进程或程序几乎可以访问计算机的任何资源，不受限制。

系统调用是用于调用操作系统提供的系统态级别的子功能的一组api：

也就是说在运行的用户程序中，凡是与系统态级别的资源有关的操作（如文件管理、进程控制、内存管理等)，都必须通过系统调用方式向操作系统提出服务请求，并由操作系统代为完成。
这些系统调用按功能大致可分为如下几类：

- 设备管理。完成设备的请求或释放，以及设备启动等功能。
- 文件管理。完成文件的读、写、创建及删除等功能。
- 进程控制。完成进程的创建、撤销、阻塞及唤醒等功能。
- 进程通信。完成进程之间的消息传递或信号传递等功能。
- 内存管理。完成内存的分配、回收以及获取作业占用内存区大小及地址等功能。

### 创建进程的系统调用有那些?
- clone()
- fork()
- vfork()
系统调用服务例程:

- sys_clone
- sys_fork
- sys_vfork

### Linux 通过什么方式实现系统调用?
靠软件中断实现的,首先,用户程序为系统调用设置参数,其中一个编号是系统调用编号,参数 
设置完成后,程序执行系统调用指令,x86 上的软中断是有 int 产生的,这个指令会导致一个异 常,
产生一个事件,这个事件会导致处理器跳转到内核态并跳转到一个新的地址
。并开始处 理那里的异常处理程序,此时的异常处理就是系统调用程序。

### Linux 软中断和工作队列的作用是什么?
Linux 中的软中断和工作队列是中断处理。

1. 软中断一般是“可延迟函数”的总称,它不能睡眠,不能阻塞,它处于中断上下文,不能进城切 换,软中断不能被自己打断,只能被硬件中断打断(上半部),可以并发的运行在多个 CPU 上。 所以软中断必须设计成可重入的函数,因此也需要自旋锁来保护其数据结构。

2. 工作队列中的函数处在进程上下文中,它可以睡眠,也能被阻塞,能够在不同的进程间切 换。已完成不同的工作。 可延迟函数和工作队列都不能访问用户的进程空间,可延时函数在执行时不可能有任何正在 运行的进程,工作队列的函数有内核进程执行,他不能访问用户空间地址

