### 1.协程的轻量级体现在哪里？
- 协程调用和切换效率比线程高：协程执行效率极高，协程不需要多线程的锁机制，可以不加锁的访问全局变量，所以上下文
切换非常快
- 协程占用内存少：协程占用的栈空间大小为4~5kB，而线程默认的栈空间是1MB
- 切换开销更小：协程直接操作栈没有内核切换的开销，所以切换开销比线程小

### 2. 线程间同步的方式有哪些？

线程间的同步方式包括互斥量，信号量，条件变量，读写锁

- 互斥量：采用互斥对象机制，只有拥有互斥对象的进程才能访问
- 信号量：计数器，允许多个进程同时访问同个资源
- 条件变量：通过条件变量通知操作的方式来保持多线程同步
- 读写锁：读写锁类似于互斥量，但是读写锁支持一个进程同时写，多个进程同时读。C++的`std::shared_mutex`是读写锁

### 3. 进程间通信方式有哪些？

- 管道：包括无名管道和命名管道，无名管道半双工，只能用于存在亲缘关系的进程间的通信，可以看做是一种特殊的文件；命名
管道可以允许无亲缘关系的进程间的通信
- 系统IPC：包括消息队列（消息的链接表，放在内核中）
- 内存共享（使多个进程访问同一个内存空间）
- socket套接字：用于不同主机之间直接的通信
- 信号量。一个整型的计数变量，原来实现进程间的同步与互斥。
- 信号。用于异常情况下的工作模式

### 4. 线程相比进程的区别？

- 多个进程之间的信息难以共享，但是线程共享同个进程的内存，如代码段，数据段，扩展段等之间进行信息交换十分方便
- 使用fork（）来创建进程的开销较大。创建线程时间开销远小于进程，无需采用写时复制来复制内存，也无需复制页表

### 5. 在单核机器上写多线程程序是否需要线程锁？

- 需要。因为线程锁通常用来实现线程的同步与通信。在单核机器上，仍然可能会存在线程的同步问题。因为在抢占式系统中，
  系统会为每个进程分配一定的时间片，当时间片耗完之后，则会将其挂起，然后运行另一个进程。如果某两个进程共享数据，那么
  在不使用线程锁的情况下，也可能会导致数据修改引起冲突
  
### 6. 说说线程池的设计思路，线程池中的线程数量由什么确定？
1. 设计思路：
   实现线程池有以下几个步骤：
   - 设置一个生产者消费者队列，作为临界资源
   - 初始化n个进程，让其运行起来，并加锁去队列里取任务执行
   - 当任务队列为空时，所有线程阻塞
   - 当生产者队列来了一个任务后，先对队列加锁，把任务挂到队列上，然后用条件变量通知阻塞中的一个线程来处理。
     

线程池中线程数量：

线程数量和哪些因素有关：CPU，IO、并行、并发

1. 如果是CPU密集型应用，则线程池大小设置为：CPU数目+1
2. 如果是IO密集型应用，则线程池大小设置为：2*CPU数目+1

3. 最佳线程数目 = （线程等待时间与线程CPU时间之比 + 1）* CPU数目


所以线程等待时间所占比例越高，需要越多线程。线程CPU时间所占比例越高，需要越少线程。

#### 为什么要创建线程池?

创建线程和销毁线程的花销是比较大的，这些时间有可能比处理业务的时间还要长。这样频繁的创建线程和销毁线程，再加上业务工作线程，消耗系统资源的时间，可能导致系统资源不足。同时线程池也是为了提升系统效率。

#### 线程池的核心线程与普通线程：

任务队列可以存放100个任务，此时为空，线程池里有10个核心线程，若突然来了10个任务，那么刚好10个核心线程直接处理；若又来了90个任务，此时核心线程来不及处理，那么有80个任务先入队列，再创建核心线程处理任务；若又来了120个任务，此时任务队列已满，不得已，就得创建20个普通线程来处理多余的任务。
以上是线程池的工作流程。

#### 进程和线程相比，为什么慢？
进程系统开销显著大于线程开销；线程需要的系统资源更少。

进程切换开销比线程大。多进程切换时需要刷新TLB并获取新的地址空间，然后切换硬件上下文和内核栈；多线程切换时只需要切换硬件上下文和内核栈。

进程通信比线程通信开销大。进程通信需要借助管道、队列、共享内存，需要额外申请空间，通信繁琐；而线程共享进程的内存，如代码段、数据段、扩展段，通信快捷简单，同步开销更小。


### 7. GDB命令格式

- quit：退出gdb，结束调试

- list：查看程序源代码

- list 5，10：显示5到10行的代码

- list test.c:5, 10: 显示源文件5到10行的代码，在调试多个文件时使用

- list get_sum: 显示get_sum函数周围的代码

- list test,c get_sum: 显示源文件get_sum函数周围的代码，在调试多个文件时使用

- reverse-search：字符串用来从当前行向前查找第一个匹配的字符串

- run：程序开始执行

- help list/all：查看帮助信息

- break：设置断点

- break 7：在第七行设置断点

- break get_sum：以函数名设置断点

- break 行号或者函数名 if 条件：以条件表达式设置断点

- watch 条件表达式：条件表达式发生改变时程序就会停下来

- next：继续执行下一条语句 ，会把函数当作一条语句执行

- step：继续执行下一条语句，会跟踪进入函数，一次一条的执行函数内的代码



#### 8.自旋锁（3.7 补充）

```c++
struct Spinlock{
    Spinlock(atomic_flag & m_flag): m_flag(flag){
        while(m_flag.test_and_set(std::memory_order_acquire));  //设定内存顺序；一共有四种memory_order
    }
    ~Spinlock(){
        m_flag.clear(std::memory_order_release);
    }
    private:
        std::atomic_flag & m_flag;
};
```

自旋锁是当没有获取锁就循环等待的一种锁，可以解决线程对于临界资源的互斥访问。

关于内存顺序，这里可能会引申出一个问题，为什么需要指定`memory_order`？
- 因为CPU会重排指令顺序，来减少访存次数，以使得程序性能提高
