### 内存为什么要字节对齐？

第一个原因——硬件设计原因，很多CPU只从对齐的地址开始加载数据，而有的CPU这样做，只是更快一点。

第二个原因——外部总线从内存一次获取的数据往往不是1byte，而是4bytes或许8bytes,或者更多。

一方面是因为我们的计算机硬件就是这么设计的，也就是说CPU在访问存储器的时候只能在某些地址处获取某些特定类型的数据。另一方面，因为CPU读取数据的时候不是一个一个读的，几个几个读的。如果数据不按照一定的规则存储的话，会降低读取速度，从而影响计算效率。

### 操作系统放在内存的低地址还是高地址？

放在虚拟内存的高地址，物理内存的低地址。

### 讲一下fork的写时复制（Copy On Write，COW），fork与vfork的区别？

fork创建子进程的时候，系统为了减少损耗，并不是一开始就复制了一份物理内存给子进程，而是复制了一份虚拟地址给子进程，父子进程的虚拟地址映射到相同的物理地址。该物理地址被标记为只读。当系统需要对该地址进行写的时候，此时系统才会调用exec函数给子进程复制一份自己的物理地址，然后他们各自的物理地址被标记为可写。

exec函数的作用是，当父进程fork出一个子进程时，通过exec函数可以把子进程复制得到的父进程的所有资源清零重置，以便运行新的程序。

而对于vfork，子进程都不用复制，直接和父进程共享虚拟地址数据段。因此每一时刻只能运行一个进程，vfork规定必须子进程先运行，直到它调用exec函数创建新程序或者_exit()函数退出，否则会发生死锁。正常退出不要用return退出，否则报错。其主要目的是创建一个和父进程不同的新程序。所以省掉了复制。

如果采用vfork，尽量立刻执行exec。vfork产生的原因就是为了子进程可以执行新的程序。

fork出来的子进程和父进程有什么区别？

Fork返回值不同，父进程返回值大于0，子进程等于0。进程ID不同。子进程需要回收。 否则变成僵尸进程。

fork()使用了写时复制的方法,减少了创建进程的内存开销。写时复制表示fork的子进程和父进程共享同一份资源,只有其中一个进程发生写事件时,才会复制资源。

vfork()也是用于创建进程的,与fork()不同的是,vfork()创建子进程后,除非子进程结束,否则父进程不能运行。

### 内核态和用户态是怎样隔离起来保证不能相互访问的？

首先要明白，CPU中有如下这些寄存器：

CS（Code segment） :代码段寄存器 IP :指令指针寄存器 DS :数据段寄存器 SS :堆栈段寄存器 SP：栈指针寄存器 ES :辅助段寄存器 AL :累加器低8位

其中我们常说的程序计数寄存器，实际上就是CS寄存器中的基地址和IP寄存器中的偏移地址，来定位到下一个将要访问的指令内存地址。PC是非intel厂家对IP的称呼，也就是说PC起始跟CS:IP是一回事儿。

前期的时候，计算方式一般为CS左移4位然后加上IP寄存器，作为地址去取内容。

CPU的制造商会为这两个寄存器设置出厂初始值，这2个初始值，其实就决定了第一条执行指令的地址，这是所有程序的源头，没有这个初始值，多么复杂精妙的程序都没用，因为CPU根本不会运作。随着X86的发展，第一条指令并不是一成不变的，



（1）8086：CPU reset后CS寄存器的值为0xFFFF，IP寄存器的值为0，所以将CS左移4位+IP，换算出的物理地址为0xFFFF0，这个地址就是1MB往下16字节的位置。

（2）80286：CPU reset之后CS的只为0xF000，IP的只为0xFFF0，算法同样是CS左移4位+IP，计算出的物理地址也是0xFFFF0

（3）80386：到了386年代，一切都变了，此时CPU reset后CS的只为0xF000，但是CS除了段选择之外还有一个隐藏的基址寄存器，这个寄存器的值为0xFFFF0000，IP的值仍然为0xFFF0，此时的计算算法也不是上面的左移4位了，而是0xFFFF0000 + 0xFFF0 = 0xFFFFFFF0，这个地址已经是很高的地址了，是4G往下16字节的位置。

在CS和SS寄存器中的第0位和第1位上（用两位表示0-3四个等级），它存储CPL，代表是当前执行的任务的特权等级。

GDT是一个全局描述符表（看起来像是用来描述段的）。

实模式的时候，访问内存是段基址加上偏移地址，但是在保护模式下，还需要一个特权级（按理说普通模式下也有特权级，不过在CS寄存器里里面，段描述符里面也有特权级）。段基址加上偏移地址特权级保存需要32位，而以前段基址寄存器只有16位装不下了，所以就创建了GDT，里面保存所有段描述符表的索引，每次访问先通过gdtr寄存器找打GDT表，根据GDTR寄存器的段选择子从表中找到要访问的段描述符表的地址并从中得到段的基地址，加上偏移地址就找到了段。

段选择子（segment selector，也有翻译为段选择符的），就是段寄存器（CS、DS、ES、SS、FS、GS）的值，实模式下段的基地址等于段寄存器的值得乘以16，保护模式下段的基地址在描述符表中给出，段选择子的高13位就是描述符表（2个，全局和局部）的索引号（0~8191）。

它里面包括段基址，段限长，DPL（表示当前段的特权级）等，它可以放在内存的任何地方，所以它的基址保存在gdtr寄存器中。GDT在整个操作系统中只有一个。

LDT是局部描述符。它的内容应该和GDT差不多（猜测），GDT就像一级描述符，它是二级描述符。ldt不是全局可见，只有用到它进程可见。系统中可以有多个ldt，但是每个进程最多只能拥有一个。它的作用是将每个进程的数据段代码段等封装在一起，每次切换进程的时候可以根据局部描述符gdt，每次改变GDTR寄存器就可以实现对不同进程的段访问。


TSS是任务状态描述符，它是内存上保存状态信息的段，用来保存全部寄存器信息。通过tr寄存器可以在GDT表中找到tss段描述符。进程中栈切换的时候会用到。栈切换时就会保存当前所有寄存器保存到tss段中，然后把放下一个tss基址覆盖到或者说放到tr寄存器中。

TSS段其实就是PCB中的一个子段。 TSS有时候还负责往新创建的栈中压入信息。TSS中也有DPL特权级位。

而在GDT和LDT中保存着DPL，表示当前段的特权等级。每次CS：IP访问的时候，会比较之前的特权级CPL和之后段的特权级DPL，最高等级是0，最低是3，如果CPL<=DPL就可以访问，否则不能访问。



### 进程经常在内存和磁盘间换入换出，怎样保证每次换入换出后进程中的指令跳转的地址不会混乱？

程序运行时会重定位地址，每段进程换入内存运行时都会在PCB中保存该进程的基地址，跳转地址指令一般都是偏移地址，跳转的时候会取出PCB中的基地址加上偏移地址得到需要跳转的地址。PCB中的LDT表保存着该进程各个段的基地址。

###如何从以文件的形式从磁盘上读取信息？

文件是以字符流的形式存在，磁盘是以多个扇区组成的磁盘块读取信息。所以要想办法将字符流和磁盘块对应起来。第一种方法是，文件的FCB中保存磁盘0-99的起始块位置，比如是磁盘块6，那么读取字符流200-212，就用200除以一个磁盘块的大小（比如是100），然后加上起始磁盘块号就可以。但是这种字符流在磁盘块中按照磁盘块的顺序保存，不能应对动态增加磁盘块的现象，因为按顺序增加磁盘块时后面的磁盘块可能被利用了导致必须得像扩容数组一样寻找一个更大的连续磁盘块空间，因此出现了索引磁盘块的形式。FCB中保存磁盘0-99的起始块位置，然后该起始磁盘块指向另一个磁盘块（不再一定是相邻磁盘块），代表100-199的字符流的位置，这样以链表的形式存储字符流，增加磁盘块随便找一个空闲磁盘块指向它即可，但是这种链表形式存储起来就比较慢了。每次读取的时候都必须从头遍历，而顺序存储每次只要除一下就可以，优缺点和顺序存储刚好相反。为了可以既方便存储读取又方便动态扩容，出现了索引形式。文件的FCB中保存磁盘块目录的位置，该磁盘块目录分别指向0-99，100-199等的磁盘块的位置，每次先找到目录，再根据目录找到需要的字符流，存储读取很快，扩容也非常快，直接再找一个指向空间存储需要的字符流大小就行。现实设计中多是使用多级索引。



### 为什么内存比磁盘快？

硬盘是有机械结构的，磁头要运动到相应的位置，转片还在转动，然后读取此信号。

内存是没有机械结构的，是电，瞬间到达。电的到达速度要比磁头的运动快很多，比盘算转动也快得多，所以，有机械结构的磁头读取速度是不能和无机械结构电的速度相比的。

### 线程数量根据什么考虑？

CPU密集型任务：一般配置线程数=CPU总核心数+1

IO密集型任务：一般配置线程数=CPU总核心数 * 2 +1 （一般情况）

CPU密集型
所谓CPU密集型就是说处理任务不需要依赖外部I/O，比如科学计算、矩阵运算等等。在这种情况下只要线程的数量和核数基本相同就可以充分利用CPU资源。
I/O密集型
这一类任务可能计算部分所占用时间不多，大部分时间都用在了比如磁盘I/O、网络I/O等，
这种情况下就稍微复杂一些了，你需要利用性能测试工具评估出用在I/O等待上的时间，这里记为WT(wait time)，以及CPU计算所需要的时间，这里极为CT(computing time)，那么对于一个N核的系统，合适的线程数大概是N * (1 + WT/CT)，假设I/O等待时间和计算时间相同，那么你大概需要2N个线程才能充分利用CPU资源，注意这只是一个理论值，具体设置多少需要根据真实的业务场景进行测试。
当然充分利用CPU不是唯一需要考虑的点，随着线程数量的增多，内存占用、系统调度、打开的文件数量、打开的socker数量以及打开的数据库链接等等是都需要考虑的。
因此这里没有万能公式，要具体情况具体分析。
12、管道能不能非父子通信？

可以，命名管道就是非父子通信。用int mkfifo(const char *name,mode_t mode)创建。第二个参数S_IFIFO|0666 指明创建一个有名管道且存取权限为0666，即创建者、与创建者同组的用户、其他用户对该有名管道的 访问权限 都是 可读可写。

### 临界区和互斥量区别是什么？能从底层说一下么

临界区主要针对线程。

互斥量比临界区复杂。因为使用互斥不仅仅能够在同一应用程序不同线程中实现资源的安全共享，而且可以在不同应用程序的线程之间实现对资源的安全共享（注意是线程）。

互斥量与临界区的作用非常相似，但互斥量是可以命名的，也就是说它可以跨越进程使用。所以创建互斥量需要的资源更多，所以如果只为了在进程内部使用的话，使用临界区会带来速度上的优势并能够减少资源占用量。因为互斥量是跨进程的互斥量一旦被创建，就可以通过名字打开它。

### 自旋锁和互斥锁的区别及应用场景？

区别：

互斥锁：抢锁失败主动放弃CPU进入睡眠，解锁的时候需要操作系统唤醒。

自旋锁：抢锁失败不放弃CPU，不断循环尝试获取锁。适用于加锁时间短的场景。

### 讲一下进程间的切换和线程间的切换？

一个进程存储在处理器各寄存器中的中间数据叫做进程的上下文，所以进程的切换实质上就是被中止运行进程与待运行进程上下文的切换。在进程未占用处理器时，进程 的上下文是存储在进程的私有堆栈中的。

进程的组成：进程控制块PCB（灵魂），还有程序（躯体）如代码、数 据、堆栈等、还有页表 。进程有3G的用户空间（用户栈）和1G的内核空间（内核栈）。

PCB主要是task_struct结构体，里面有一个void*stack指针指向内核栈，还有一个mm指针指向用户栈地址。

进程陷入内核态后，先把用户态堆栈的地址保存在内核栈之中。我怀疑就是保存在内核栈中的PCB中。

进程的上下文：用户级上下文（地址空间中的程序块，数据块，堆栈等 ），系统级上下文（PCB、内核栈等），寄存器上下文（硬件上下文）。

上下文切换时，操作系统把进程的寄存器上下文保存到系统级上下文中。因为PCB比较小，不能容纳那么多信息，所以大多数信息保存在内核栈和另外一个地方(linux中)，然后PCB中有一个指针指向内核栈等，内核栈中保存现场和断点。

什么时候发生上下文切换？
自身造成切换，运行态变为阻塞态（自身产生一个异常、等待资源，启动IO），外界强制下切换，运行态变为就绪态（时间片、优先级等），上下文切换的频率1s中可以达到100-1000次左右。

PCB和内核栈什么关系？



进程中的PCB的指针指向内核栈。内核栈里保存有进程上下文切换的各个寄存器的信息。每次切换完进程之后，新的进程根据当前进程PCB中的指向内核栈的指针，拿到该进程运行所需要的寄存器的信息。

PCB也在内核栈里面，一般切换时信息都是保存在PCB中，PCB装不下就用个指针指向内核栈进行保存。

进程间切换：

1.切换新的页表，然后使用新的虚拟地址空间

2.切换内核栈，加入新的内容(PCB控制块，资源相关)，硬件上下文切换

线程切换只有第二步。



最后进程间切换步骤总结：


先把原有CPU中的SP寄存器值保存到内核栈，然后新的SP栈指针指向内核栈。再保存PSW寄存器值，然后PC原来指向正在运行的程序，后来被保存到内核栈，PC新的值指向中断处理程序，在该程序中再把其他的通用寄存器保存到内核栈。

1.首先把该进程对应的CPU中的SP寄存器（栈指针指向用户栈运行的地方）中的值保存在PCB中（PCB中也存有指向内核栈的指针），使用栈指令把其他寄存器（如PC寄存器（程序计数器）和PSW（标志寄存器）、CS寄存器（断点））的值保存到内核栈 。

2.把该进程的PCB的状态位从运行态修改为其他就绪态或者阻塞态。

3.把切换后的进程的PCB的加入运行队列，并修改状态为为运行态。

4.从切换后进程的PCB中拿到它的私有堆栈指针保存到CPU的SP寄存器中，然后根据这个指针找到它的内核栈，从中弹出上下文进入CPU处理器中，最后利用中断从堆栈中弹出开始运行。



### 硬链接和软链接

- 硬链接： 与普通文件相同，inode都指向了同一文件在硬盘中的区号
- 软链接：保存了其代表的文件的绝对路径，是另一种文件，在硬盘上有独立的区号，访问时替换自身路径



### 2. 互斥锁的实现

> https://www.zhihu.com/question/332113890/answer/2443011003

mutex的本质是一个内存标志，这个标志可以是一个flag（占用标志），也可以是一个指针，指向一个持有者的线程ID，也可以是两者都有，以及一个等待（阻塞）队列，以及若干其他信息。当这个flag被标记为占用，或者持有者的指针不为空的时候，它就不能被别的任务（线程）访问。只有等到这个mutex释放之后，操作系统会把等待队列里的第一任务（线程）取出来，然后调度执行，如果当前CPU很忙，那么就把取出的这个任务标记为就绪状态，如果后绪CPU空闲了，就会被调度。

值得一提的是，互斥锁本身存在操作系统重新调度和上下文切换的开销，而自旋锁避免了这部分开销，自旋锁可以通过一组原子指令来实现，像C++里头提供了atomic原子类型，它提供的CAS操作可以用来封装自旋锁，所以非常有效，在操作系统里头也经常用到自旋锁。

