## 一、写在前面

今天整理下关于幂等设计。


## 二、幂等

### 1、什么是幂等

在数学中，幂等用函数表达式就是：`f(x) = f(f(x))`。如果一个函数f(x) ，满足该表达式，则该函数是幂等的。
比如求绝对值的函数，就是幂等的，`abs(x) = abs(abs(x))`。

计算机科学中，幂等表示一次和多次请求某一个资源应该具有同样的副作用，或者说，多次请求所产生的影响与一次请求执行的影响效果相同。

### 2、为什么需要幂等

举个例子：

> 我们开发一个转账功能，假设我们调用下游接口**超时**了。一般情况下，**超时**可能是**网络传输丢包**的问题，也可能是请求时没送到，还有可能是请求到了，**返回结果却丢**了。这时候我们是否可以重试呢？如果**重试**的话，是否会多转了一笔钱呢？

![图片](https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1PmpxeyzObyfYibjcRaKONiaHMNVGvaRbu8oC0PiaFic7PJoZZpw1A4XqOibM3NOianfWQZHsQpbr7ZDZDzSHQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)



当前互联网的系统几乎都是解耦隔离后，会存在各个不同系统的相互远程调用。调用远程服务会有三个状态：成功，失败，或者超时。前两者都是明确的状态，而超时则是**未知状态**。我们转账**超时**的时候，如果下游转账系统做好**幂等**控制，我们发起**重试**，那即可以**保证转账正常进行，又可以保证不会多转一笔**。

其实除了转账这个例子，日常开发中，还有**很多很多例子需要考虑幂等**。比如：

- MQ（消息中间件）消费者读取消息时，有可能会读取到重复消息。（**重复消费**）

- 比如提交form表单时，如果快速点击提交按钮，可能产生了两条一样的数据（**前端重复提交**）

- 再比如前端提交form表单到后台，进行操作数据库的时候。（GET PUT DEL 都是幂等的，POST不是幂等的）

  

> 注意，通常幂等性**通常**都是下游保证的，即在RPC的过程中，上游只负责失败重试，具体的幂等性由下游保证。
>
> 如果想让上游保证的话，下游需要提供一个查询接口。详见下一节。



### 3、接口超时，如何处理呢？

如果我们调用下游接口超时了，我们应该怎么处理呢？

有**两种方案**处理：分别由

- 方案一：就是下游系统提供一个对应的查询接口。如果接口超时了，先查下对应的记录，如果查到是成功，就走成功流程，如果是失败，就按失败处理。

> 拿我们的转账例子来说，转账系统提供一个查询**转账记录**的接口，如果**渠道系统**调用**转账系统**超时时，**渠道系统**先去查询一下这笔记录，看下这笔转账记录成功还是失败，如果成功就走成功流程，失败再重试发起转账。

![图片](https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1PmpxeyzObyfYibjcRaKONiaHMNVpWeU3ceyopgnwMQoQV0D6SoYLWpl8IHHAoc9y9uXicbHMrtU7cdtahA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

- 方案二：下游接口**支持幂等**，上游系统如果**调用超时**，发起重试即可。

![图片](https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1PmpxeyzObyfYibjcRaKONiaHMNV9BN3VXKYZ6bnel9V4zfvRhsyDlql8vYeyZjEym3mb6nicQKROj6j8ZQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

两种方案都是挺不错的，但是如果是**MQ重复消费的场景**，方案一处理并不是很妥，所以，我们还是要求下游系统**对外接口支持幂等**。





1. 如何设计幂等？
2. 实现幂等的8种方案
3. HTTP的幂等
