[来源](https://www.nowcoder.com/tutorial/93/a34ed23d58b84da3a707c70371f59c21)
# C++基础知识——基本语言

**1. static关键字作用**
> 参见[C++中的static关键字的总结](https://www.cnblogs.com/beyondanytime/archive/2012/06/08/2542315.html)
- 全局静态变量。在全局变量前，加上关键字static。
    - 有以下特点
        - 该变量在全局数据区分配内存
        - 未经初始化的静态全局变量会被程序自动初始化为0
        - 静态全局变量在声明它的整个文件都是可见的，而在文件之外是不可见的；
    - 有以下好处
        - 静态全局变量不能被其它文件所用
        - 其它文件中可以定义相同名字的变量，不会发生冲突；
    - 示例为
    ```
    #include <iostream.h>
    void fn();
    static int n; //定义静态全局变量
    void main()
    {
    　　n=20;
    　　cout<<n<<endl;
    　　fn();
    }

    void fn()
    {
    　　 n++;
    　　cout<<n<<endl;
    }
    ```
- 局部静态变量。在局部变量之前加上关键字static
    - 内存中的位置：静态存储区
    - 初始化：自动初始化为0
    - 作用域：作用域仍为局部作用域，但一直存在内存中。但再次调用函数时，该变量使用内存中值。
- 静态函数。函数返回类型前加static
    - 函数的实现使用static修饰，那么这个函数只可在本cpp内使用，不会同其他cpp中的同名函数冲突。
- 类的静态成员
    - 静态成员可以实现多个对象之间的数据共享。只存一处，供多个对象使用
- 类的静态函数
    - 调用静态成员函数使用如下格式：<类名>::<静态成员函数名>(<参数表>);
    - 类的所有对象共用
    - 静态函数实现中不能调用费静态成员

**2. C++和C的区别**
- 设计思想上：
    - C++是面向对象的语言，而C是面向过程的结构化编程语言
- 语法上：
    - C++支持类，具有封装、继承和多态三种特性
    - C++相比C，增加多许多类型安全的功能，比如强制类型转换、
    - C++支持范式编程，比如模板类、函数模板等
    - C++支持函数和运算符重载
    - C++支持引用
    - C++提供new和delete来申请释放内存， 而c通过malloc, free
    - C++完全兼容C语法。
    - C使用namespace避免不同文件中的命名冲突
    - C++类支持virtual和friend函数
        - virtual函数是实现父类指针指向子类实例，通过父类指针调用虚函数时，实现多态的机制
        - 纯虚函数是在基类中声明的虚函数，它在基类中没有定义，但要求任何派生类都要定义自己的实现方法。
        - friend function被定义在函数外，但是希望访问类的所有权限成员，可在类中将该函数声明为friend.friend函数/类不是类的成员


**3. C++中四种cast转换**
- C++中四种类型转换是：static_cast, dynamic_cast, const_cast, reinterpret_cast
    - const_cast。用于将const变量转为非const
    - static_cast。用于各种隐式转换，比如非const转const，void*转指针等, static_cast能用于多态向上转化，如果向下转能成功但是不安全，结果未知；
    - dynamic_cast。用于动态类型转换。只能用于含有虚函数的类，用于类层次间的向上和向下转化。只能转指针或引用。向下转化时，如果是非法的对于指针返回NULL，对于引用抛异常。要深入了解内部转换的原理。向上转换：指的是子类向基类的转换；向下转换：指的是基类向子类的转换。它通过判断在执行到该语句的时候变量的运行时类型和要转换的类型是否相同来判断是否能够进行向下转换。
    - reinterpret_cast。几乎什么都可以转，比如将int转指针，可能会出问题，尽量少用；

**4. C/C++ 中指针和引用的区别?**
- 指针有自己的一块空间，而引用只是一个别名；
- 使用sizeof看一个指针的大小是4，而引用则是被引用对象的大小；
- 指针可以被初始化为NULL，而引用必须被初始化且必须是一个已有对象 的引用；
- 作为参数传递时，指针需要被解引用才可以对对象进行操作，而直接对引 用的修改都会改变引用所指向的对象；
- 可以有const指针，但是没有const引用；
- 指针在使用中可以指向其它对象，但是引用只能是一个对象的引用，不能 被改变；
- 指针可以有多级指针（**p），而引用至于一级；
- 指针和引用使用++运算符的意义不一样；指针++代表指向指针指向地址增加size,引用使用++代表引用对象自增
- 如果返回动态内存分配的对象或者内存，必须使用指针，引用可能引起内存泄露。


** 5. c++中的smart pointer四个智能指针： shared_ptr,unique_ptr,weak_ptr,auto_ptr**
- 为何使用智能指针？
    - 避免指针申请的内存空间忘记释放，造成内存泄漏。智能指针就是一个类，当超出了类实例的作用域是，类实例会自动调用析构函数
- 四种智能指针类型
    - auto_ptr， c98使用， c11弃用
        - 采用所有权模式。
    
        ```
        //此时不会报错，p2剥夺了p1的所有权，但是当程序运行时访问p1将会报错。
        auto_ptr< string> p1 (new string ("I reigned lonely as a cloud.”));
        auto_ptr<string> p2;
        p2 = p1; //auto_ptr不会报错.
        ```
        - unique_ptr（替换auto_ptr）。unique_ptr实现独占式拥有或严格拥有概念，保证同一时间内只有一个智能指针可以指向该对象。且，临时右值赋值不会告警。
        ```
        unique_ptr<string> p3 (new string ("auto"));   //#4
        unique_ptr<string> p4；                       //#5
        p4 = p3;//此时会报错！！
        ```
        - shared_ptr。shared_ptr实现共享式拥有概念。多个智能指针可以指向相同对象，该对象和其相关资源会在“最后一个引用被销毁”时候释放。
            - 成员函数：use_count 返回引用计数的个数；unique 返回是否是独占所有权( use_count 为 1)；swap 交换两个 shared_ptr 对象(即交换所拥有的对象)；reset 放弃内部对象的所有权或拥有对象的变更, 会引起原有对象的引用计数的减少；get 返回内部对象(指针), 由于已经重载了()方法, 因此和直接使用对象是一样的.如 shared_ptr<int> sp(new int(1)); sp 与 sp.get()是等价的
        - weak_ptr。协助 shared_ptr 工作, 它只可以从一个 shared_ptr 或另一个 weak_ptr 对象构造, 它的构造和析构不会引起引用记数的增加或减少。weak_ptr是用来解决shared_ptr相互引用时的死锁问题。

**5. 数组和指针区别**
- 数组
    - 保存数据
    - 直接访问数据
    - 通常用于固定数目且数据类型相同的元素
    - 隐式的分配和删除
    - 自身即为数据名
- 指针
    - 保存数据的地址
    - 间接访问数据，首先获得指针的内容，然后将其作为地址，从该地址中提取数据
    - 通常用于动态的数据结构
    - 通过Malloc分配内存，free释放内存
    - 通常指向匿名数据，操作匿名函数

**6. 野指针是什么？**
- 野指针就是指向一个已删除的对象或者未申请访问受限内存区域的指针